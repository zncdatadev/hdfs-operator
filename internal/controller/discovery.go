package controller

import (
	"context"
	"fmt"
	"strings"

	"emperror.dev/errors"
	hdfsv1alpha1 "github.com/zncdatadev/hdfs-operator/api/v1alpha1"
	"github.com/zncdatadev/hdfs-operator/internal/common"
	"github.com/zncdatadev/hdfs-operator/internal/util"
	listenerv1alpha1 "github.com/zncdatadev/operator-go/pkg/apis/listeners/v1alpha1"
	"github.com/zncdatadev/operator-go/pkg/builder"
	pkgclient "github.com/zncdatadev/operator-go/pkg/client"
	"github.com/zncdatadev/operator-go/pkg/reconciler"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	ctrl "sigs.k8s.io/controller-runtime"
	ctrlclient "sigs.k8s.io/controller-runtime/pkg/client"
)

var discoveryLog = ctrl.Log.WithName("discovery")

var (
	ErrListenerNotFound          = errors.New("listener resource not found")
	ErrListenerAddressesNotFound = errors.New("listener addresses not found")
)

func NewHdfsDiscovery(
	client *pkgclient.Client,
	instance *hdfsv1alpha1.HdfsCluster,
	clusterInfo reconciler.ClusterInfo) reconciler.ResourceReconciler[builder.ConfigBuilder] {
	discoveryBuilder := NewDiscoveryConfigMapBuilder(client, instance, clusterInfo)
	return reconciler.NewGenericResourceReconciler(client, discoveryBuilder)
}

// DiscoveryConfigMapBuilder implements discovery-specific ConfigMap logic
type DiscoveryConfigMapBuilder struct {
	builder.ConfigMapBuilder
	instance *hdfsv1alpha1.HdfsCluster
	client   *pkgclient.Client
}

// NewDiscoveryConfigMapBuilder creates a new DiscoveryConfigMapBuilder
func NewDiscoveryConfigMapBuilder(
	client *pkgclient.Client,
	instance *hdfsv1alpha1.HdfsCluster,
	clusterInfo reconciler.ClusterInfo,
) builder.ConfigBuilder {
	return &DiscoveryConfigMapBuilder{
		ConfigMapBuilder: *builder.NewConfigMapBuilder(
			client,
			clusterInfo.GetFullName(),
			func(o *builder.Options) {
				o.Annotations = clusterInfo.GetAnnotations()
				o.Labels = clusterInfo.GetLabels()
			},
		),
		instance: instance,
		client:   client,
	}
}

// Build constructs the ConfigMap directly without using the common builder infrastructure
func (b *DiscoveryConfigMapBuilder) Build(ctx context.Context) (ctrlclient.Object, error) {
	hdfsSiteXml, err := b.makeHdfsSiteXmlData(ctx)
	if err != nil {
		return nil, err
	}

	return &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      b.instance.GetName(),
			Namespace: b.instance.Namespace,
			Labels: map[string]string{
				common.LabelCrName:    b.instance.GetName(),
				common.LabelManagedBy: "hdfs-operator",
				common.LabelComponent: "discovery",
			},
		},
		Data: map[string]string{
			"core-site.xml": b.makeCoreSiteXmlData(),
			"hdfs-site.xml": hdfsSiteXml,
		},
	}, nil
}

func (b *DiscoveryConfigMapBuilder) makeCoreSiteXmlData() string {
	generator := common.CoreSiteXmlGenerator{InstanceName: b.instance.Name, IsDiscovery: true}
	return generator.EnableKerberos(b.instance.Spec.ClusterConfig, b.instance.Namespace).Generate()
}

func (b *DiscoveryConfigMapBuilder) makeHdfsSiteXmlData(ctx context.Context) (string, error) {
	xml := util.NewXmlConfiguration(b.commonHdfsSiteXml())
	properties, err := b.makeDynamicHdfsSiteXml(ctx)
	if err != nil {
		return "", err
	}
	if common.IsKerberosEnabled(b.instance.Spec.ClusterConfig) {
		properties = append(properties, common.SecurityDiscoveryHdfsSiteXml()...)
	}
	return xml.String(properties), nil
}

// make hdfs-site.xml data
func (b *DiscoveryConfigMapBuilder) commonHdfsSiteXml() []util.XmlNameValuePair {
	return []util.XmlNameValuePair{
		{
			Name:  "dfs.nameservices",
			Value: b.instance.GetName(),
		},
		{
			Name:  "dfs.client.failover.proxy.provider." + b.instance.GetName(),
			Value: "org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider",
		},
	}
}

func (b *DiscoveryConfigMapBuilder) makeDynamicHdfsSiteXml(ctx context.Context) ([]util.XmlNameValuePair, error) {
	var hosts util.XmlNameValuePair
	var podNames []string
	var connections []util.XmlNameValuePair
	var err error
	nameNodeGroups := b.instance.Spec.NameNode.RoleGroups

	// get pod names
	podNames = b.getPodNames(nameNodeGroups)
	// make discovery hosts
	hosts = b.makeDiscoveryHosts(podNames)
	// make connections
	if connections, err = b.createConnections(ctx, podNames); err != nil {
		return nil, err
	}

	all := make([]util.XmlNameValuePair, 0, 1+len(connections))
	all = append(all, hosts)
	all = append(all, connections...)
	return all, nil
}

// get pod names
// Note: pod name generated by group name and replicas
func (b *DiscoveryConfigMapBuilder) getPodNames(nameNodeGroups map[string]hdfsv1alpha1.RoleGroupSpec) []string {
	var podNames []string
	for groupName := range nameNodeGroups {
		// We need to get pod names from namenode role groups based on replicas
		// Since discovery doesn't have access to the cache, we'll need to calculate from the spec directly
		if roleGroup, ok := nameNodeGroups[groupName]; ok {
			nameNodeStatefulSetName := fmt.Sprintf("%s-namenode-%s", b.instance.Name, groupName)
			if roleGroup.Replicas != nil {
				replicas := *roleGroup.Replicas
				for i := int32(0); i < replicas; i++ {
					podName := fmt.Sprintf("%s-%d", nameNodeStatefulSetName, i)
					podNames = append(podNames, podName)
				}
			}
		}
	}
	return podNames
}

// make discovery hosts
func (b *DiscoveryConfigMapBuilder) makeDiscoveryHosts(podNames []string) util.XmlNameValuePair {
	return util.XmlNameValuePair{
		Name:  "dfs.ha.namenodes." + b.instance.GetName(),
		Value: strings.Join(podNames, ","),
	}
}

// create http and rpc address
// http key pattern: "dfs.namenode.http-address.{hdfs_instance_name}.{podName}"
// rpc key pattern: "dfs.namenode.rpc-address.{hdfs_instance_name}.{podName}"
// http key example:
//
//	dfs.namenode.http-address.simple-hdfs.simple-hdfs-namenode-default-0
//	dfs.namenode.http-address.simple-hdfs.simple-hdfs-namenode-default-1
//
// rpc key example:
//
//	dfs.namenode.rpc-address.simple-hdfs.simple-hdfs-namenode-default-0
//	dfs.namenode.rpc-address.simple-hdfs.simple-hdfs-namenode-default-1
//
// value pattern: "{listener_address}:{listener_port}"
// value example:
//
//	0.0.0.0:9870
func (b *DiscoveryConfigMapBuilder) createPortNameAddress(
	ctx context.Context,
	podNames []string,
	portName string,
	cache *map[string]*listenerv1alpha1.IngressAddressSpec) ([]util.XmlNameValuePair, error) {
	connections := make([]util.XmlNameValuePair, 0, len(podNames))
	for _, podName := range podNames {
		var address *listenerv1alpha1.IngressAddressSpec
		var err error
		if address, err = b.getListenerAddress(cache, ctx, podName); err != nil {
			return nil, err
		}
		port, err := b.getPort(address, portName)
		if err != nil {
			discoveryLog.Error(err, "failed to get port from address by port name", "address",
				address, "portName", portName)
			return nil, err
		}

		name := fmt.Sprintf("dfs.namenode.%s-address.%s.%s", portName, b.instance.GetName(), podName)
		value := fmt.Sprintf("%s:%d", address.Address, port)
		connections = append(connections, util.XmlNameValuePair{Name: name, Value: value})
	}
	return connections, nil
}

// create discovery connections
func (b *DiscoveryConfigMapBuilder) createConnections(ctx context.Context, podNames []string) ([]util.XmlNameValuePair, error) {
	cache := make(map[string]*listenerv1alpha1.IngressAddressSpec)
	var httpConnections, rpcConnections []util.XmlNameValuePair
	var err error
	var connections []util.XmlNameValuePair
	// create http address
	schema := "http"
	if common.IsTlsEnabled(b.instance.Spec.ClusterConfig) {
		schema = "https"
	}
	httpConnections, err = b.createPortNameAddress(ctx, podNames, schema, &cache)
	if err != nil {
		discoveryLog.Info("failed to create http connections")
		return nil, err
	} else {
		connections = append(connections, httpConnections...)
	}

	// create rpc address
	rpcConnections, err = b.createPortNameAddress(ctx, podNames, hdfsv1alpha1.RpcName, &cache)
	if err != nil {
		discoveryLog.Info("failed to create rpc connections")
	} else {
		connections = append(connections, rpcConnections...)
	}
	return connections, nil
}

// get port from address by port name
func (b *DiscoveryConfigMapBuilder) getPort(address *listenerv1alpha1.IngressAddressSpec, portName string) (int32, error) {
	for name, port := range address.Ports {
		if name == portName {
			return port, nil
		}
	}
	return 0, errors.Errorf("not found port in address %s by port name", portName)
}
func (b *DiscoveryConfigMapBuilder) getListenerAddress(
	cache *map[string]*listenerv1alpha1.IngressAddressSpec,
	ctx context.Context,
	podName string) (*listenerv1alpha1.IngressAddressSpec, error) {

	listenerName, err := b.getListenerNameByPodName(ctx, podName)
	if err != nil {
		discoveryLog.Info("failed to get listener name by pod name", "podName", podName, "namespace", b.instance.Namespace)
		return nil, err
	}
	cacheKey := listenerName
	cacheObj := *cache
	if address, ok := cacheObj[cacheKey]; ok {
		return address, nil
	}

	// get listener
	listener := &listenerv1alpha1.Listener{
		ObjectMeta: metav1.ObjectMeta{
			Name:      cacheKey,
			Namespace: b.instance.Namespace,
		},
	}
	err = b.client.Get(ctx, ctrlclient.ObjectKey{Name: cacheKey, Namespace: b.instance.Namespace}, listener)
	if err != nil {
		discoveryLog.Info("failed to get listener", "cacheKey", cacheKey)
		return nil, ErrListenerNotFound
	}

	listenerAddresses := listener.Status.IngressAddresses
	if len(listenerAddresses) == 0 {
		discoveryLog.Info("not found listener address", "namespace", b.instance.Namespace,
			"name", b.instance.Name, "listener.status", listener.Status)
		return nil, ErrListenerAddressesNotFound
	}
	address := &listener.Status.IngressAddresses[0]
	cacheObj[cacheKey] = address
	return address, nil
}

// get listener name from pod's lable
// label pattern: "listeners.kubedoop.dev/mnt.{listener_uid}: {listener_name}"
// the pod can be fetched by pod name,namespaces
func (b *DiscoveryConfigMapBuilder) getListenerNameByPodName(ctx context.Context, podName string) (string, error) {
	pod := &corev1.Pod{
		ObjectMeta: metav1.ObjectMeta{
			Name:      podName,
			Namespace: b.instance.Namespace,
		},
	}
	err := b.client.Get(ctx, ctrlclient.ObjectKey{Name: podName, Namespace: b.instance.Namespace}, pod)
	if err != nil {
		discoveryLog.Info("failed to get pod", "podName", podName)
		return "", err
	}

	for key, value := range pod.Labels {
		if strings.HasPrefix(key, "listeners.kubedoop.dev/mnt") {
			return value, nil
		}
	}
	return "", errors.New("not found listener name by pod name")
}
